#!/usr/bin/env python

# stdlib imports
import argparse
import os.path
from configobj import ConfigObj
import urllib.request
import urllib.error
import urllib.parse
import tempfile
import re
import shutil

# third party imports
from mapio.shake import getHeaderData
from mapio.gdal import GDALGrid
import numpy as np

# local imports
from gfail.conf import correct_config_filepaths
import gfail.logisticmodel as LM
from gfail.godt import godt2008
from gfail.savelayers import savelayers
from gfail.makemaps import (parseConfigLayers, parseMapConfig,
                            modelMap, interactiveMap)
from gfail.webpage import makeWebpage
from mapio.shake import ShakeGrid

def main(args):
    # TODO: ADD CONFIG VALIDATION STEP THAT MAKES SURE ALL THE FILES EXIST
    if args.set_default_paths:
        set_default_paths(args)
        print('default paths set, continuing...\n')

    if args.list_default_paths:
        list_default_paths()
        return

    if args.reset_default_paths:
        reset_default_paths()
        return

    # Figure out what models will be run
    if args.shakefile is not None:  # user intends to actually run some models
        shakefile = args.shakefile
        # make output location for things
        if args.output_filepath is None:
            outdir = os.getcwd()
        else:
            outdir = args.output_filepath

        if (args.hdf5 or args.make_static_pngs or
                args.make_static_pdfs or
                args.make_interactive_plots or
                args.gis):
            if not os.path.exists(outdir):
                os.makedirs(outdir)

        # download if is url
        cleanup = False
        if not os.path.isfile(shakefile):
            if isURL(shakefile):
                # getGridURL returns a named temporary file object
                shakefile = getGridURL(shakefile)
                cleanup = True  # Be sure to delete it after
            else:
                raise NameError('Could not find "%s" as a file or a valid url'
                                % (shakefile))
                return
        eventid = getHeaderData(shakefile)[0]['event_id']

        if args.nest_folder:
            outfolder = os.path.join(outdir, eventid)
            if not os.path.exists(outfolder):
                os.makedirs(outfolder)
        else:
            outfolder = outdir

        config = args.config
        if args.config_filepath is not None:
            # only add config_filepath if full filepath not given and file
            # ext is .ini
            if (not os.path.isabs(config) and
                    os.path.splitext(config)[-1] == '.ini'):
                config = os.path.join(args.config_filepath, config)

        if os.path.splitext(config)[-1] == '.ini':
            temp = ConfigObj(config)
            if args.data_path is not None:
                temp = correct_config_filepaths(args.data_path, temp)
            configs = [temp]
            conffail = []
        else:
            # input is a list of config files
            f = open(config, 'r')
            configlist = f.readlines()
            configs = []
            conffail = []
            for conf in configlist:
                conf = conf.replace('\n', '')
                if not os.path.isabs(conf):
                    # only add config_filepath if full filepath not given
                    conf = os.path.join(args.config_filepath, conf)
                try:
                    temp = ConfigObj(conf)
                    if temp:
                        if args.data_path is not None:
                            temp = correct_config_filepaths(args.data_path,
                                                            temp)
                        configs.append(temp)
                    else:
                        conffail.append(conf)
                except:
                    conffail.append(conf)

        print('Running the following models:\n')
        for conf in configs:
            print('\t%s\n' % conf.keys()[0])
        if len(conffail) > 0:
            print('Could not find or read in the following config files:\n')
            for conf in conffail:
                print('\t%s\n' % conf)
            print('\nContinuing...\n')

        if args.set_bounds is not None:
            if 'zoom' in args.set_bounds:
                temp = args.set_bounds.split(',')
                print('Using %s threshold of %1.1f to cut model bounds'
                      % (temp[1].strip(), float(temp[2].strip())))
                bounds = get_bounds(shakefile, temp[1].strip(),
                                    float(temp[2].strip()))
            else:
                temp = eval(args.set_bounds)
                latmin = temp[0]
                latmax = temp[1]
                lonmin = temp[2]
                lonmax = temp[3]
                bounds = {'xmin': lonmin, 'xmax': lonmax,
                          'ymin': latmin, 'ymax': latmax}
            print('Applying bounds of lonmin %1.2f, lonmax %1.2f, '
                  'latmin %1.2f, latmax %1.2f'
                  % (bounds['xmin'], bounds['xmax'],
                     bounds['ymin'], bounds['ymax']))
        else:
            bounds = None
        filenames = []
        if args.make_webpage:
            results = []

        # Loop over config files
        for conf in configs:
            modelname = conf.keys()[0]
            print('Now running %s' % modelname)
            modelfunc = conf[modelname]['funcname']
            if modelfunc == 'LogisticModel':
                lm = LM.LogisticModel(
                    shakefile,
                    conf,
                    uncertfile=args.uncertfile,
                    saveinputs=args.save_inputs,
                    bounds=bounds,
                    numstd=float(args.std))
                maplayers = lm.calculate()
            elif modelfunc == 'godt2008':
                maplayers = godt2008(
                    shakefile,
                    conf,
                    uncertfile=args.uncertfile,
                    saveinputs=args.save_inputs,
                    bounds=bounds,
                    numstd=float(args.std))
            else:
                print('Unknown model function specified in config for %s '
                      'model, skipping to next config' % modelfunc)
                continue
            # time1 = datetime.datetime.utcnow().strftime('%d%b%Y_%H%M')
            # filename = ('%s_%s_%s' % (eventid, modelname, time1))
            if args.appendname is not None:
                filename = ('%s_%s_%s' % (eventid, modelname, args.appendname))
            else:
                filename = ('%s_%s' % (eventid, modelname))
            if args.hdf5:
                filenameh = filename + '.hdf5'
                savelayers(maplayers, os.path.join(outfolder, filenameh))

            if args.make_static_pdfs or args.make_static_pngs:
                plotorder, logscale, lims, colormaps, maskthreshes = \
                    parseConfigLayers(maplayers, conf)
                mapconfig = ConfigObj(args.mapconfig)

                kwargs = parseMapConfig(
                    mapconfig, fileext=args.mapdata_filepath)
                junk, filenames1 = modelMap(
                    maplayers, shakefile,
                    suptitle=conf[modelname]['shortref'],
                    boundaries=None,
                    zthresh=0.,
                    lims=lims,
                    plotorder=plotorder,
                    maskthreshes=maskthreshes,
                    maproads=False,
                    mapcities=True,
                    colormaps=colormaps,
                    savepdf=args.make_static_pdfs,
                    savepng=args.make_static_pngs,
                    printparam=True,
                    inventory_shapefile=None,
                    outputdir=outfolder,
                    outfilename=filename,
                    scaletype='continuous',
                    logscale=logscale, **kwargs)
                for filen in filenames1:
                    filenames.append(filen)

                # make model only plots too
                if len(maplayers) > 1:
                    plotorder, logscale, lims, colormaps, maskthreshes = \
                        parseConfigLayers(maplayers, conf, keys=['model'])
                    junk, filenames1 = modelMap(
                        maplayers, shakefile,
                        suptitle=conf[modelname]['shortref'], boundaries=None,
                        zthresh=0., lims=lims, plotorder=plotorder,
                        maskthreshes=maskthreshes, maproads=False,
                        mapcities=True, savepdf=args.make_static_pdfs,
                        savepng=args.make_static_pngs, printparam=True,
                        inventory_shapefile=None, outputdir=outfolder,
                        outfilename=filename + '-just_model',
                        colormaps=colormaps, scaletype='continuous',
                        logscale=logscale, **kwargs)
                    for filen in filenames1:
                        filenames.append(filen)
            if args.make_interactive_plots:
                plotorder, logscale, lims, colormaps, maskthreshes = \
                    parseConfigLayers(maplayers, conf)
                junk, filenames1 = interactiveMap(
                    maplayers, plotorder=plotorder, shakefile=shakefile,
                    inventory_shapefile=None, maskthreshes=maskthreshes,
                    colormaps=colormaps, isScenario=False,
                    scaletype='continuous', lims=lims, logscale=logscale,
                    ALPHA=0.7, outputdir=outfolder, outfilename=filename,
                    tiletype='Stamen Terrain', separate=True,
                    faultfile=args.finite_fault)
                for filen in filenames1:
                    filenames.append(filen)
            if args.make_webpage:
                results.append(maplayers)
            if args.gis:

                for key in maplayers:
                    # Get simplified name of key for file naming
                    RIDOF = '[+-]?(?=\d*[.eE])(?=\.?\d)'\
                            '\d*\.?\d*(?:[eE][+-]?\d+)?'
                    OPERATORPAT = '[\+\-\*\/]*'
                    keyS = re.sub(OPERATORPAT, '', key)
                    # remove floating point numbers
                    keyS = re.sub(RIDOF, '', keyS)
                    # remove parentheses
                    keyS = re.sub('[()]*', '', keyS)
                    # remove any blank spaces
                    keyS = keyS.replace(' ', '')
                    filen = os.path.join(outfolder, '%s_%s.bil'
                                         % (filename, keyS))
                    GDALGrid.copyFromGrid(maplayers[key]['grid']).save(filen)
                    filenames.append(filen)

        if args.make_webpage:
            webloc = makeWebpage(results, configs, args.web_template,
                                 shakefile, outfolder=outfolder,
                                 includeAlert=args.alert, cleanup=True,
                                 faultfile=args.finite_fault)
            filenames.append(webloc)

        # Write shakefile to a file for use later
        shake_file = open(os.path.join(outfolder, "shakefile.txt"), "w")
        shake_file.write(shakefile)
        shake_file.close()

        print('\nFiles created:\n')
        for filen in filenames:
            print('%s' % filen)

        if cleanup:
            shutil.rm(shakefile)


def getGridURL(gridurl):
    """
    Args:
        gridurl (str): url for Shakemap grid.xml file.

    Returns:
        file object corresponding to the url.
    """

    f = None
    fh = None
    with urllib.request.urlopen(gridurl) as fh:
        data = fh.read().decode('utf-8')
        with tempfile.NamedTemporaryFile(delete=False, mode='w') as f:
            f.write(data)

    return f.name


def isURL(gridurl):
    """
    This function determines if the provided string is a valid url

    Args:
        gridurl (str): url to check.

    Returns:
        bool: True if griurl is a valid url, False otherwise.
    """

    isURL = False
    try:
        urllib.request.urlopen(gridurl)
        isURL = True
    except:
        pass
    return isURL


def set_default_paths(args):
    """
    Creates a file called .gfail_defaults that contains default path
    information to simplify running gfail. Can be overwritten by any manually
    entered paths. This updates any existing .gfail_defaults file. If
    args.data_path is 'reset' then any existing defaults will be removed.
    """
    filename = os.path.join(os.path.expanduser('~'), '.gfail_defaults')
    if os.path.exists(filename):
        D = ConfigObj(filename)
    else:
        D = {}
    if args.data_path is not None:
        if args.data_path == 'reset':
            D.pop('data_path')
        else:
            # check that it's a valid path
            if os.path.exists(args.data_path):
                D.update({'data_path': args.data_path})
            else:
                print('Path given for data_path does not exist: %s'
                      % args.data_path)
    if args.output_filepath is not None:
        if args.output_filepath == 'reset':
            D.pop('output_filepath')
        else:
            # check that it's a valid path
            if os.path.exists(args.output_filepath):
                D.update({'output_filepath': args.output_filepath})
            else:
                print('Path given for output_filepath does not exist: %s'
                      % args.output_filepath)
    if args.config_filepath is not None:
        if args.config_filepath == 'reset':
            D.pop('config_filepath')
        else:
            # check that it's a valid path
            if os.path.exists(args.config_filepath):
                D.update({'config_filepath': args.config_filepath})
            else:
                print('Path given for config_filepath does not exist: %s'
                      % args.config_filepath)
    if args.mapconfig is not None:
        if args.mapconfig == 'reset':
            D.pop('mapconfig')
        else:
            # check that it's a valid path
            if os.path.exists(args.mapconfig):
                D.update({'mapconfig': args.mapconfig})
            else:
                print('Path given for mapconfig does not exist: %s'
                      % args.mapconfig)
    if args.mapdata_filepath is not None:
        if args.mapdata_filepath == 'reset':
            D.pop('mapdata_filepath')
        else:
            # check that it's a valid path
            if os.path.exists(args.mapdata_filepath):
                D.update({'mapdata_filepath': args.mapdata_filepath})
            else:
                print('Path given for mapdata_filepath does not exist: %s'
                      % args.mapdata_filepath)
    if args.web_template is not None:
        if args.web_template == 'reset':
            D.pop('web_template')
        else:
            # check that it's a valid path
            if os.path.exists(args.web_template):
                D.update({'web_template': args.web_template})
            else:
                print('Path given for webpage templates does not exist: %s'
                      % args.web_template)
    print('New default paths set.\n')

    if D:
        C = ConfigObj(D)
        C.filename = filename
        C.write()
        list_default_paths()
    else:
        print('no defaults set because no paths were input\n')


def list_default_paths():
    """
    Lists all default paths currently set.
    """
    filename = os.path.join(os.path.expanduser('~'), '.gfail_defaults')
    if os.path.exists(filename):
        D = ConfigObj(filename)
        print('Default paths currently set to:\n')
        for key in D:
            print('\t%s = %s' % (key, D[key]))
    else:
        print('No default paths currently set\n')


def reset_default_paths():
    """
    Clear default path file
    """
    filename = os.path.join(os.path.expanduser('~'), '.gfail_defaults')
    if os.path.exists(filename):
        os.remove(filename)
        print('Default paths cleared\n')
    else:
        print('No default paths currently set\n')


def get_bounds(shakefile, parameter='pga', threshold=2):
    """
    Get the boundaries of the shakemap that include all areas with shaking
    above the defined threshold.

    Args:
        shakefile (str): Path to shakemap file.
        parameter (str): Either 'pga' or 'pgv'.
        threshold (float): Minimum value of parameter of interest, in units
            of %g for pga and cm/s for pgv. The default value of 2 %g is based
            on minimum pga threshold ever observed to have triggered landslides
            from Jibson and Harp (2016).

    Returns:
        dict: A dictionary with keys 'xmin', 'xmax', 'ymin', and 'ymax' and
        some dummy keys that are unused.
    """
    shakemap = ShakeGrid.load(shakefile, adjust='res')
    if parameter == 'pga':
        vals = shakemap.getLayer('pga')
    elif parameter == 'pgv':
        vals = shakemap.getLayer('pgv')
    else:
        raise Exception('parameter not valid')
    xmin, xmax, ymin, ymax = vals.getBounds()
    lons = np.linspace(xmin, xmax, vals.getGeoDict().nx)
    lats = np.linspace(ymax, ymin, vals.getGeoDict().ny)
    row, col = np.where(vals.getData() > float(threshold))
    lonmin = lons[col].min()
    lonmax = lons[col].max()
    latmin = lats[row].min()
    latmax = lats[row].max()

    # dummy fillers, only really care about bounds
    boundaries1 = {'dx': 100, 'dy': 100., 'nx': 100., 'ny': 100}

    if xmin < lonmin:
        boundaries1['xmin'] = lonmin
    else:
        boundaries1['xmin'] = xmin
    if xmax > lonmax:
        boundaries1['xmax'] = lonmax
    else:
        boundaries1['xmax'] = xmax
    if ymin < latmin:
        boundaries1['ymin'] = latmin
    else:
        boundaries1['ymin'] = ymin
    if ymax > latmax:
        boundaries1['ymax'] = latmax
    else:
        boundaries1['ymax'] = ymax

    return boundaries1


if __name__ == '__main__':

    # See if there is a default path file, load in if there is and
    # replace any nones
    defaults = os.path.join(os.path.expanduser('~'), '.gfail_defaults')
    data_path = None
    output_filepath = None
    config_filepath = None
    mapconfig = None
    mapdata_filepath = None
    web_template = os.path.join(
        os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'pelican', 'theme')

    if os.path.exists(defaults):
        D = ConfigObj(defaults)
        for key in D:
            if key == 'data_path':
                data_path = D[key]
            elif key == 'output_filepath':
                output_filepath = D[key]
            elif key == 'config_filepath':
                config_filepath = D[key]
            elif key == 'mapconfig':
                mapconfig = D[key]
            elif key == 'mapdata_filepath':
                mapdata_filepath = D[key]
            elif key == 'web_template':
                web_template = D[key]

    parser = argparse.ArgumentParser(
        description='Run ground failure models on input ShakeMap grid.')
    parser.add_argument(
        'config', metavar='config', nargs='?',
        help='single config file of model to run (.ini extension), or text '
             'file listing config files (do not use .ini extension)')
    parser.add_argument(
        'shakefile', nargs='?',
        help='single ShakeMap grid.xml file or url')
    parser.add_argument(
        '-u', '--uncertfile', metavar='uncertfile', nargs='?',
        help='single ShakeMap uncertainty.xml file', default=None)
    parser.add_argument(
        '-d', '--data-path', metavar='datafilepath', nargs='?',
        default=data_path,
        help='Set file path to model input data (only needed if file paths '
        'in config are relative)')
    parser.add_argument(
        '-o', '--output-filepath', metavar='outfilepath', nargs='?',
        default=output_filepath,
        help='Filepath for output files, uses current directory if '
             'not specified')
    parser.add_argument(
        '-c', '--config-filepath', metavar='configfilepath', nargs='?',
        default=config_filepath,
        help='Filepath where config files are located, default is '
             'defaultconfigfiles folder of groundfailure repository')
    parser.add_argument(
        '-b', '--set-bounds', type=str,
        metavar=('latmin, latmax, lonmin, lonmax'), nargs='?',
        help="Set bounds of model run using four floats in this format, "
             "including quotes: 'latmin, latmax, lonmin, lonmax', default "
             "uses shakemap bounds, 'zoom, parameter, threshold' in single "
             "quotes uses a shakemap threshold value, e.g. 'zoom, pga, 2' "
             "where 2 is in percent g",
        default=None)
    parser.add_argument(
        '-m', '--mapconfig', metavar='mapconfig', nargs='?',
        help='full file path to config file containing mapping options',
        default=mapconfig)
    parser.add_argument(
        '-md', '--mapdata-filepath', metavar='mapdatapath', nargs='?',
        help='Set file path to mapping input data (only needed if file '
             'paths in mapconfig are relative)',
        default=mapdata_filepath)
    parser.add_argument(
        '-s', '--std', metavar='numstd', nargs='?',
        help='Number of ground motion standard deviations to use '
             '(only used if uncertainty file used)',
        default=1.)
    parser.add_argument(
        '-a', '--appendname', metavar='appendname', nargs='?',
        help='append word to file names to describe current run',
        default=None)
    parser.add_argument(
        '-t', '--web-template', metavar='template', nargs='?',
        default=web_template,
        help='location of directory containing pelican files and templates')
    parser.add_argument(
        '-f', '--finite-fault', metavar='finitefault', nargs='?',
        default=None, help='geojson file to show on interactive maps')

    # Binary
    parser.add_argument(
        '-i', '--save-inputs', action='store_true', default=False,
        help='Save input layer grids with model output')
    parser.add_argument(
        '--hdf5', action='store_true', default=False,
        help='Save model results as MultiHazard HDF file (MapIO)')
    parser.add_argument(
        '--gis', action='store_true', default=False,
        help='Save GIS file (ESRI .bil format) of model result')
    parser.add_argument(
        '-pd', '--make-static-pdfs', action='store_true', default=False,
        help='Make static plots for each model')
    parser.add_argument(
        '-pn', '--make-static-pngs', action='store_true', default=False,
        help='Make static plots for each model')
    parser.add_argument(
        '-pi', '--make-interactive-plots', action='store_true', default=False,
        help='Make interactive html plots for each model')
    parser.add_argument(
        '-l', '--list-default-paths', action='store_true', default=False,
        help='See listing of currently set default paths')
    parser.add_argument(
        '-set', '--set-default-paths', action='store_true', default=False,
        help='Sets paths given as inputs as defaults '
             '(overwrites existing values)')
    parser.add_argument(
        '-reset', '--reset-default-paths', action='store_true', default=False,
        help='Clears all existing default paths')
    parser.add_argument(
        '-w', '--make-webpage', action='store_true', default=False,
        help='Create webpage that summarizes all model results, '
             'including interactive maps')
    parser.add_argument(
        '-n', '--nest-folder', action='store_true', default=True,
        help='do not nest in output folder with eventid as name '
             '(default is it will nest)')
    parser.add_argument(
        '--alert', action='store_true', default=False,
        help='Determine and report alert levels. Default is false')
    #parser.add_argument('-e', '--exercise', action='store_true', default=False,
    #                    help='Exercise tests (for developers)')

    pargs = parser.parse_args()
    main(pargs)
